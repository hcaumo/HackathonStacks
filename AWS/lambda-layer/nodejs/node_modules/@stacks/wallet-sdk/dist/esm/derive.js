import { bytesToHex, ChainID, TransactionVersion, utf8ToBytes } from '@stacks/common';
import { compressPrivateKey, createSha2Hash } from '@stacks/encryption';
import { StacksMainnet } from '@stacks/network';
import { getAddressFromPrivateKey } from '@stacks/transactions';
import { HARDENED_OFFSET } from './models/common';
import { fetchFirstName } from './usernames';
import { assertIsTruthy, whenChainId } from './utils';
const DATA_DERIVATION_PATH = `m/888'/0'`;
const WALLET_CONFIG_PATH = `m/44/5757'/0'/1`;
const STX_DERIVATION_PATH = `m/44'/5757'/0'/0`;
export const deriveWalletKeys = async (rootNode) => {
    assertIsTruthy(rootNode.privateKey);
    return {
        salt: await deriveSalt(rootNode),
        rootKey: rootNode.privateExtendedKey,
        configPrivateKey: bytesToHex(deriveConfigPrivateKey(rootNode)),
    };
};
export const deriveConfigPrivateKey = (rootNode) => {
    const derivedConfigKey = rootNode.derive(WALLET_CONFIG_PATH).privateKey;
    if (!derivedConfigKey)
        throw new TypeError('Unable to derive config key for wallet identities');
    return derivedConfigKey;
};
export const deriveLegacyConfigPrivateKey = (rootNode) => {
    const derivedLegacyKey = rootNode.deriveChild(45 + HARDENED_OFFSET).privateKey;
    if (!derivedLegacyKey)
        throw new TypeError('Unable to derive config key for wallet identities');
    return bytesToHex(derivedLegacyKey);
};
export const deriveSalt = async (rootNode) => {
    const identitiesKeychain = rootNode.derive(DATA_DERIVATION_PATH);
    const publicKeyHex = utf8ToBytes(bytesToHex(identitiesKeychain.publicKey));
    const sha2Hash = await createSha2Hash();
    const saltData = await sha2Hash.digest(publicKeyHex, 'sha256');
    return bytesToHex(saltData);
};
export var DerivationType;
(function (DerivationType) {
    DerivationType[DerivationType["Wallet"] = 0] = "Wallet";
    DerivationType[DerivationType["Data"] = 1] = "Data";
    DerivationType[DerivationType["Unknown"] = 2] = "Unknown";
})(DerivationType || (DerivationType = {}));
export const selectStxDerivation = async ({ username, rootNode, index, network, }) => {
    if (username) {
        const stxDerivationTypeForUsername = await selectDerivationTypeForUsername({
            username,
            rootNode,
            index,
            network,
        });
        return { username, stxDerivationType: stxDerivationTypeForUsername };
    }
    else {
        const { username, derivationType } = await selectUsernameForAccount({
            rootNode,
            index,
            network,
        });
        return { username, stxDerivationType: derivationType };
    }
};
const selectDerivationTypeForUsername = async ({ username, rootNode, index, network, }) => {
    if (network) {
        const nameInfo = await network.getNameInfo(username);
        let stxPrivateKey = deriveStxPrivateKey({ rootNode, index });
        let derivedAddress = getAddressFromPrivateKey(stxPrivateKey);
        if (derivedAddress !== nameInfo.address) {
            stxPrivateKey = deriveDataPrivateKey({
                rootNode,
                index,
            });
            derivedAddress = getAddressFromPrivateKey(stxPrivateKey);
            if (derivedAddress !== nameInfo.address) {
                return DerivationType.Unknown;
            }
            else {
                return DerivationType.Data;
            }
        }
        else {
            return DerivationType.Wallet;
        }
    }
    else {
        return DerivationType.Unknown;
    }
};
const selectUsernameForAccount = async ({ rootNode, index, network, }) => {
    if (network) {
        const txVersion = whenChainId(network.chainId)({
            [ChainID.Mainnet]: TransactionVersion.Mainnet,
            [ChainID.Testnet]: TransactionVersion.Testnet,
        });
        const stxPrivateKey = deriveStxPrivateKey({ rootNode, index });
        const address = getAddressFromPrivateKey(stxPrivateKey, txVersion);
        let username = await fetchFirstName(address, network);
        if (username) {
            return { username, derivationType: DerivationType.Wallet };
        }
        else {
            const dataPrivateKey = deriveDataPrivateKey({ rootNode, index });
            const address = getAddressFromPrivateKey(dataPrivateKey, txVersion);
            username = await fetchFirstName(address, network);
            if (username) {
                return { username, derivationType: DerivationType.Data };
            }
        }
    }
    return { username: undefined, derivationType: DerivationType.Wallet };
};
export const fetchUsernameForAccountByDerivationType = async ({ rootNode, index, derivationType, network, }) => {
    const selectedNetwork = network ?? new StacksMainnet();
    const txVersion = whenChainId(selectedNetwork.chainId)({
        [ChainID.Mainnet]: TransactionVersion.Mainnet,
        [ChainID.Testnet]: TransactionVersion.Testnet,
    });
    const privateKey = derivePrivateKeyByType({ rootNode, index, derivationType });
    const address = getAddressFromPrivateKey(privateKey, txVersion);
    const username = await fetchFirstName(address, selectedNetwork);
    return { username };
};
export const derivePrivateKeyByType = ({ rootNode, index, derivationType, }) => {
    return derivationType === DerivationType.Wallet
        ? deriveStxPrivateKey({ rootNode, index })
        : deriveDataPrivateKey({ rootNode, index });
};
export const deriveStxPrivateKey = ({ rootNode, index }) => {
    const childKey = rootNode.derive(STX_DERIVATION_PATH).deriveChild(index);
    assertIsTruthy(childKey.privateKey);
    return bytesToHex(compressPrivateKey(childKey.privateKey));
};
export const deriveDataPrivateKey = ({ rootNode, index }) => {
    const childKey = rootNode.derive(DATA_DERIVATION_PATH).deriveChild(index + HARDENED_OFFSET);
    assertIsTruthy(childKey.privateKey);
    return bytesToHex(compressPrivateKey(childKey.privateKey));
};
export const deriveAccount = ({ rootNode, index, salt, stxDerivationType, }) => {
    const stxPrivateKey = stxDerivationType === DerivationType.Wallet
        ? deriveStxPrivateKey({ rootNode, index })
        : deriveDataPrivateKey({ rootNode, index });
    const identitiesKeychain = rootNode.derive(DATA_DERIVATION_PATH);
    const identityKeychain = identitiesKeychain.deriveChild(index + HARDENED_OFFSET);
    if (!identityKeychain.privateKey)
        throw new Error('Must have private key to derive identities');
    const dataPrivateKey = bytesToHex(identityKeychain.privateKey);
    const appsKey = identityKeychain.deriveChild(0 + HARDENED_OFFSET).privateExtendedKey;
    return {
        stxPrivateKey,
        dataPrivateKey,
        appsKey,
        salt,
        index,
    };
};
//# sourceMappingURL=derive.js.map