import { bytesToHex, ChainID } from '@stacks/common';
import { getPublicKeyFromPrivate, publicKeyToBtcAddress, randomBytes } from '@stacks/encryption';
import { createFetchFn } from '@stacks/network';
import { TokenSigner } from 'jsontokens';
import { parseZoneFile } from 'zone-file';
export function assertIsTruthy(val) {
    if (!val) {
        throw new Error(`expected: true, actual: ${val}`);
    }
}
export const getProfileURLFromZoneFile = async (name, fetchFn = createFetchFn()) => {
    const url = `https://api.hiro.so/v1/names/${name}`;
    const res = await fetchFn(url);
    if (res.ok) {
        const nameInfo = await res.json();
        const zone = parseZoneFile(nameInfo.zonefile);
        const uri = zone.uri?.[0]?.target;
        if (uri) {
            return uri;
        }
        throw new Error(`No zonefile uri found: ${nameInfo.zonefile}`);
    }
    return;
};
export const getHubInfo = async (gaiaHubUrl, fetchFn = createFetchFn()) => {
    const response = await fetchFn(`${gaiaHubUrl}/hub_info`);
    const data = await response.json();
    return data;
};
const makeGaiaAuthToken = ({ hubInfo, privateKey, gaiaHubUrl, }) => {
    const challengeText = hubInfo.challenge_text;
    const iss = getPublicKeyFromPrivate(privateKey);
    const salt = bytesToHex(randomBytes(16));
    const payload = {
        gaiaHubUrl,
        iss,
        salt,
    };
    if (challengeText) {
        payload.gaiaChallenge = challengeText;
    }
    const token = new TokenSigner('ES256K', privateKey).sign(payload);
    return `v1:${token}`;
};
export const connectToGaiaHubWithConfig = ({ hubInfo, privateKey, gaiaHubUrl, }) => {
    const readURL = hubInfo.read_url_prefix;
    const token = makeGaiaAuthToken({ hubInfo, privateKey, gaiaHubUrl });
    const address = publicKeyToBtcAddress(getPublicKeyFromPrivate(privateKey));
    return {
        url_prefix: readURL,
        max_file_upload_size_megabytes: 100,
        address,
        token,
        server: gaiaHubUrl,
    };
};
export const makeGaiaAssociationToken = ({ privateKey: secretKeyHex, childPublicKeyHex, }) => {
    const LIFETIME_SECONDS = 365 * 24 * 3600;
    const signerKeyHex = secretKeyHex.slice(0, 64);
    const compressedPublicKeyHex = getPublicKeyFromPrivate(signerKeyHex);
    const salt = bytesToHex(randomBytes(16));
    const payload = {
        childToAssociate: childPublicKeyHex,
        iss: compressedPublicKeyHex,
        exp: LIFETIME_SECONDS + new Date().getTime() / 1000,
        iat: Date.now() / 1000,
        salt,
    };
    const tokenSigner = new TokenSigner('ES256K', signerKeyHex);
    const token = tokenSigner.sign(payload);
    return token;
};
export function whenChainId(chainId) {
    return (chainIdMap) => chainIdMap[chainId];
}
//# sourceMappingURL=utils.js.map