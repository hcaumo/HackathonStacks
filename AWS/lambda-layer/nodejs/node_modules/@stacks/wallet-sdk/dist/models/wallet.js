"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.restoreWalletAccounts = void 0;
const __1 = require("..");
const derive_1 = require("../derive");
const utils_1 = require("../utils");
const common_1 = require("./common");
const legacy_wallet_config_1 = require("./legacy-wallet-config");
const wallet_config_1 = require("./wallet-config");
async function restoreWalletAccounts({ wallet, gaiaHubUrl, network, }) {
    const hubInfo = await (0, utils_1.getHubInfo)(gaiaHubUrl, network.fetchFn);
    const rootNode = (0, common_1.getRootNode)(wallet);
    const legacyGaiaConfig = (0, utils_1.connectToGaiaHubWithConfig)({
        hubInfo,
        privateKey: (0, derive_1.deriveLegacyConfigPrivateKey)((0, common_1.getRootNode)(wallet)),
        gaiaHubUrl,
    });
    const currentGaiaConfig = (0, utils_1.connectToGaiaHubWithConfig)({
        hubInfo,
        privateKey: wallet.configPrivateKey,
        gaiaHubUrl,
    });
    const [walletConfig, legacyWalletConfig] = await Promise.all([
        (0, wallet_config_1.fetchWalletConfig)({ wallet, gaiaHubConfig: currentGaiaConfig, fetchFn: network.fetchFn }),
        (0, legacy_wallet_config_1.fetchLegacyWalletConfig)({ wallet, gaiaHubConfig: legacyGaiaConfig, fetchFn: network.fetchFn }),
    ]);
    if (walletConfig &&
        walletConfig.accounts.length >= (legacyWalletConfig?.identities.length || 0)) {
        const newAccounts = await Promise.all(walletConfig.accounts.map(async (_, index) => {
            let existingAccount = wallet.accounts[index];
            const { username } = await (0, __1.fetchUsernameForAccountByDerivationType)({
                rootNode,
                index,
                derivationType: __1.DerivationType.Wallet,
                network,
            });
            if (!existingAccount) {
                existingAccount = (0, derive_1.deriveAccount)({
                    rootNode,
                    index,
                    salt: wallet.salt,
                    stxDerivationType: __1.DerivationType.Wallet,
                });
            }
            else {
                existingAccount = {
                    ...existingAccount,
                    stxPrivateKey: (0, __1.deriveStxPrivateKey)({
                        rootNode,
                        index,
                    }),
                };
            }
            return {
                ...existingAccount,
                username,
            };
        }));
        return {
            ...wallet,
            accounts: newAccounts,
        };
    }
    if (legacyWalletConfig) {
        const newAccounts = await Promise.all(legacyWalletConfig.identities.map(async (_, index) => {
            let existingAccount = wallet.accounts[index];
            const { username } = await (0, __1.fetchUsernameForAccountByDerivationType)({
                rootNode,
                index,
                derivationType: __1.DerivationType.Wallet,
                network,
            });
            if (!existingAccount) {
                existingAccount = (0, derive_1.deriveAccount)({
                    rootNode,
                    index,
                    salt: wallet.salt,
                    stxDerivationType: __1.DerivationType.Wallet,
                });
            }
            else {
                existingAccount = {
                    ...existingAccount,
                    stxPrivateKey: (0, __1.deriveStxPrivateKey)({
                        rootNode,
                        index,
                    }),
                };
            }
            return {
                ...existingAccount,
                username,
            };
        }));
        const meta = {};
        if (legacyWalletConfig.hideWarningForReusingIdentity) {
            meta.hideWarningForReusingIdentity = true;
        }
        const newConfig = {
            accounts: legacyWalletConfig.identities.map(identity => ({
                username: identity.username,
                apps: identity.apps,
            })),
            meta,
        };
        await (0, wallet_config_1.updateWalletConfig)({
            wallet,
            walletConfig: newConfig,
            gaiaHubConfig: currentGaiaConfig,
        });
        return {
            ...wallet,
            accounts: newAccounts,
        };
    }
    return wallet;
}
exports.restoreWalletAccounts = restoreWalletAccounts;
//# sourceMappingURL=wallet.js.map