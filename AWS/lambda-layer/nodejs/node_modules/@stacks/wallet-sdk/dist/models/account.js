"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeAuthResponse = exports.getAppPrivateKey = exports.getAccountDisplayName = exports.getStxAddress = void 0;
const bip32_1 = require("@scure/bip32");
const auth_1 = require("@stacks/auth");
const common_1 = require("@stacks/common");
const encryption_1 = require("@stacks/encryption");
const network_1 = require("@stacks/network");
const transactions_1 = require("@stacks/transactions");
const utils_1 = require("../utils");
const common_2 = require("./common");
const profile_1 = require("./profile");
const getStxAddress = ({ account, transactionVersion = transactions_1.TransactionVersion.Testnet, }) => {
    return (0, transactions_1.getAddressFromPrivateKey)(account.stxPrivateKey, transactionVersion);
};
exports.getStxAddress = getStxAddress;
const getAccountDisplayName = (account) => {
    if (account.username) {
        return account.username.split('.')[0];
    }
    return `Account ${account.index + 1}`;
};
exports.getAccountDisplayName = getAccountDisplayName;
const getAppPrivateKey = ({ account, appDomain, }) => {
    const hashBytes = (0, encryption_1.hashSha256Sync)((0, common_1.utf8ToBytes)(`${appDomain}${account.salt}`));
    const hash = (0, common_1.bytesToHex)(hashBytes);
    const appIndex = (0, encryption_1.hashCode)(hash);
    const appsNode = bip32_1.HDKey.fromExtendedKey(account.appsKey);
    const appKeychain = appsNode.deriveChild(appIndex + common_2.HARDENED_OFFSET);
    if (!appKeychain.privateKey)
        throw 'Needs private key';
    return (0, common_1.bytesToHex)(appKeychain.privateKey);
};
exports.getAppPrivateKey = getAppPrivateKey;
const makeAuthResponse = async ({ account, appDomain, transitPublicKey, scopes = [], gaiaHubUrl, appPrivateKeyFromWalletSalt = null, additionalData = {}, fetchFn = (0, network_1.createFetchFn)(), }) => {
    const appPrivateKey = (0, exports.getAppPrivateKey)({ account, appDomain });
    const hubInfo = await (0, utils_1.getHubInfo)(gaiaHubUrl, fetchFn);
    const profileUrl = await (0, profile_1.fetchAccountProfileUrl)({ account, gaiaHubUrl: hubInfo.read_url_prefix });
    const profile = (await (0, profile_1.fetchProfileFromUrl)(profileUrl, fetchFn)) || profile_1.DEFAULT_PROFILE;
    if (scopes.includes('publish_data')) {
        if (!profile.apps) {
            profile.apps = {};
        }
        const publicKey = (0, encryption_1.getPublicKeyFromPrivate)(appPrivateKey);
        const address = (0, encryption_1.publicKeyToBtcAddress)(publicKey);
        const storageUrl = `${hubInfo.read_url_prefix}${address}/`;
        profile.apps[appDomain] = storageUrl;
        if (!profile.appsMeta) {
            profile.appsMeta = {};
        }
        profile.appsMeta[appDomain] = {
            storage: storageUrl,
            publicKey,
        };
        const gaiaHubConfig = (0, utils_1.connectToGaiaHubWithConfig)({
            hubInfo,
            privateKey: account.dataPrivateKey,
            gaiaHubUrl,
        });
        await (0, profile_1.signAndUploadProfile)({ profile, account, gaiaHubUrl, gaiaHubConfig });
    }
    const compressedAppPublicKey = (0, encryption_1.getPublicKeyFromPrivate)(appPrivateKey.slice(0, 64));
    const associationToken = (0, utils_1.makeGaiaAssociationToken)({
        privateKey: account.dataPrivateKey,
        childPublicKeyHex: compressedAppPublicKey,
    });
    return (0, auth_1.makeAuthResponse)(account.dataPrivateKey, {
        ...(profile || {}),
        stxAddress: {
            testnet: (0, exports.getStxAddress)({ account, transactionVersion: transactions_1.TransactionVersion.Testnet }),
            mainnet: (0, exports.getStxAddress)({ account, transactionVersion: transactions_1.TransactionVersion.Mainnet }),
        },
        ...additionalData,
    }, {
        profileUrl,
    }, undefined, appPrivateKey, undefined, transitPublicKey, gaiaHubUrl, undefined, associationToken, appPrivateKeyFromWalletSalt);
};
exports.makeAuthResponse = makeAuthResponse;
//# sourceMappingURL=account.js.map