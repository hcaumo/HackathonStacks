"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.whenChainId = exports.makeGaiaAssociationToken = exports.connectToGaiaHubWithConfig = exports.getHubInfo = exports.getProfileURLFromZoneFile = exports.assertIsTruthy = void 0;
const common_1 = require("@stacks/common");
const encryption_1 = require("@stacks/encryption");
const network_1 = require("@stacks/network");
const jsontokens_1 = require("jsontokens");
const zone_file_1 = require("zone-file");
function assertIsTruthy(val) {
    if (!val) {
        throw new Error(`expected: true, actual: ${val}`);
    }
}
exports.assertIsTruthy = assertIsTruthy;
const getProfileURLFromZoneFile = async (name, fetchFn = (0, network_1.createFetchFn)()) => {
    const url = `https://api.hiro.so/v1/names/${name}`;
    const res = await fetchFn(url);
    if (res.ok) {
        const nameInfo = await res.json();
        const zone = (0, zone_file_1.parseZoneFile)(nameInfo.zonefile);
        const uri = zone.uri?.[0]?.target;
        if (uri) {
            return uri;
        }
        throw new Error(`No zonefile uri found: ${nameInfo.zonefile}`);
    }
    return;
};
exports.getProfileURLFromZoneFile = getProfileURLFromZoneFile;
const getHubInfo = async (gaiaHubUrl, fetchFn = (0, network_1.createFetchFn)()) => {
    const response = await fetchFn(`${gaiaHubUrl}/hub_info`);
    const data = await response.json();
    return data;
};
exports.getHubInfo = getHubInfo;
const makeGaiaAuthToken = ({ hubInfo, privateKey, gaiaHubUrl, }) => {
    const challengeText = hubInfo.challenge_text;
    const iss = (0, encryption_1.getPublicKeyFromPrivate)(privateKey);
    const salt = (0, common_1.bytesToHex)((0, encryption_1.randomBytes)(16));
    const payload = {
        gaiaHubUrl,
        iss,
        salt,
    };
    if (challengeText) {
        payload.gaiaChallenge = challengeText;
    }
    const token = new jsontokens_1.TokenSigner('ES256K', privateKey).sign(payload);
    return `v1:${token}`;
};
const connectToGaiaHubWithConfig = ({ hubInfo, privateKey, gaiaHubUrl, }) => {
    const readURL = hubInfo.read_url_prefix;
    const token = makeGaiaAuthToken({ hubInfo, privateKey, gaiaHubUrl });
    const address = (0, encryption_1.publicKeyToBtcAddress)((0, encryption_1.getPublicKeyFromPrivate)(privateKey));
    return {
        url_prefix: readURL,
        max_file_upload_size_megabytes: 100,
        address,
        token,
        server: gaiaHubUrl,
    };
};
exports.connectToGaiaHubWithConfig = connectToGaiaHubWithConfig;
const makeGaiaAssociationToken = ({ privateKey: secretKeyHex, childPublicKeyHex, }) => {
    const LIFETIME_SECONDS = 365 * 24 * 3600;
    const signerKeyHex = secretKeyHex.slice(0, 64);
    const compressedPublicKeyHex = (0, encryption_1.getPublicKeyFromPrivate)(signerKeyHex);
    const salt = (0, common_1.bytesToHex)((0, encryption_1.randomBytes)(16));
    const payload = {
        childToAssociate: childPublicKeyHex,
        iss: compressedPublicKeyHex,
        exp: LIFETIME_SECONDS + new Date().getTime() / 1000,
        iat: Date.now() / 1000,
        salt,
    };
    const tokenSigner = new jsontokens_1.TokenSigner('ES256K', signerKeyHex);
    const token = tokenSigner.sign(payload);
    return token;
};
exports.makeGaiaAssociationToken = makeGaiaAssociationToken;
function whenChainId(chainId) {
    return (chainIdMap) => chainIdMap[chainId];
}
exports.whenChainId = whenChainId;
//# sourceMappingURL=utils.js.map