"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveAccount = exports.deriveDataPrivateKey = exports.deriveStxPrivateKey = exports.derivePrivateKeyByType = exports.fetchUsernameForAccountByDerivationType = exports.selectStxDerivation = exports.DerivationType = exports.deriveSalt = exports.deriveLegacyConfigPrivateKey = exports.deriveConfigPrivateKey = exports.deriveWalletKeys = void 0;
const common_1 = require("@stacks/common");
const encryption_1 = require("@stacks/encryption");
const network_1 = require("@stacks/network");
const transactions_1 = require("@stacks/transactions");
const common_2 = require("./models/common");
const usernames_1 = require("./usernames");
const utils_1 = require("./utils");
const DATA_DERIVATION_PATH = `m/888'/0'`;
const WALLET_CONFIG_PATH = `m/44/5757'/0'/1`;
const STX_DERIVATION_PATH = `m/44'/5757'/0'/0`;
const deriveWalletKeys = async (rootNode) => {
    (0, utils_1.assertIsTruthy)(rootNode.privateKey);
    return {
        salt: await (0, exports.deriveSalt)(rootNode),
        rootKey: rootNode.privateExtendedKey,
        configPrivateKey: (0, common_1.bytesToHex)((0, exports.deriveConfigPrivateKey)(rootNode)),
    };
};
exports.deriveWalletKeys = deriveWalletKeys;
const deriveConfigPrivateKey = (rootNode) => {
    const derivedConfigKey = rootNode.derive(WALLET_CONFIG_PATH).privateKey;
    if (!derivedConfigKey)
        throw new TypeError('Unable to derive config key for wallet identities');
    return derivedConfigKey;
};
exports.deriveConfigPrivateKey = deriveConfigPrivateKey;
const deriveLegacyConfigPrivateKey = (rootNode) => {
    const derivedLegacyKey = rootNode.deriveChild(45 + common_2.HARDENED_OFFSET).privateKey;
    if (!derivedLegacyKey)
        throw new TypeError('Unable to derive config key for wallet identities');
    return (0, common_1.bytesToHex)(derivedLegacyKey);
};
exports.deriveLegacyConfigPrivateKey = deriveLegacyConfigPrivateKey;
const deriveSalt = async (rootNode) => {
    const identitiesKeychain = rootNode.derive(DATA_DERIVATION_PATH);
    const publicKeyHex = (0, common_1.utf8ToBytes)((0, common_1.bytesToHex)(identitiesKeychain.publicKey));
    const sha2Hash = await (0, encryption_1.createSha2Hash)();
    const saltData = await sha2Hash.digest(publicKeyHex, 'sha256');
    return (0, common_1.bytesToHex)(saltData);
};
exports.deriveSalt = deriveSalt;
var DerivationType;
(function (DerivationType) {
    DerivationType[DerivationType["Wallet"] = 0] = "Wallet";
    DerivationType[DerivationType["Data"] = 1] = "Data";
    DerivationType[DerivationType["Unknown"] = 2] = "Unknown";
})(DerivationType || (exports.DerivationType = DerivationType = {}));
const selectStxDerivation = async ({ username, rootNode, index, network, }) => {
    if (username) {
        const stxDerivationTypeForUsername = await selectDerivationTypeForUsername({
            username,
            rootNode,
            index,
            network,
        });
        return { username, stxDerivationType: stxDerivationTypeForUsername };
    }
    else {
        const { username, derivationType } = await selectUsernameForAccount({
            rootNode,
            index,
            network,
        });
        return { username, stxDerivationType: derivationType };
    }
};
exports.selectStxDerivation = selectStxDerivation;
const selectDerivationTypeForUsername = async ({ username, rootNode, index, network, }) => {
    if (network) {
        const nameInfo = await network.getNameInfo(username);
        let stxPrivateKey = (0, exports.deriveStxPrivateKey)({ rootNode, index });
        let derivedAddress = (0, transactions_1.getAddressFromPrivateKey)(stxPrivateKey);
        if (derivedAddress !== nameInfo.address) {
            stxPrivateKey = (0, exports.deriveDataPrivateKey)({
                rootNode,
                index,
            });
            derivedAddress = (0, transactions_1.getAddressFromPrivateKey)(stxPrivateKey);
            if (derivedAddress !== nameInfo.address) {
                return DerivationType.Unknown;
            }
            else {
                return DerivationType.Data;
            }
        }
        else {
            return DerivationType.Wallet;
        }
    }
    else {
        return DerivationType.Unknown;
    }
};
const selectUsernameForAccount = async ({ rootNode, index, network, }) => {
    if (network) {
        const txVersion = (0, utils_1.whenChainId)(network.chainId)({
            [common_1.ChainID.Mainnet]: common_1.TransactionVersion.Mainnet,
            [common_1.ChainID.Testnet]: common_1.TransactionVersion.Testnet,
        });
        const stxPrivateKey = (0, exports.deriveStxPrivateKey)({ rootNode, index });
        const address = (0, transactions_1.getAddressFromPrivateKey)(stxPrivateKey, txVersion);
        let username = await (0, usernames_1.fetchFirstName)(address, network);
        if (username) {
            return { username, derivationType: DerivationType.Wallet };
        }
        else {
            const dataPrivateKey = (0, exports.deriveDataPrivateKey)({ rootNode, index });
            const address = (0, transactions_1.getAddressFromPrivateKey)(dataPrivateKey, txVersion);
            username = await (0, usernames_1.fetchFirstName)(address, network);
            if (username) {
                return { username, derivationType: DerivationType.Data };
            }
        }
    }
    return { username: undefined, derivationType: DerivationType.Wallet };
};
const fetchUsernameForAccountByDerivationType = async ({ rootNode, index, derivationType, network, }) => {
    const selectedNetwork = network ?? new network_1.StacksMainnet();
    const txVersion = (0, utils_1.whenChainId)(selectedNetwork.chainId)({
        [common_1.ChainID.Mainnet]: common_1.TransactionVersion.Mainnet,
        [common_1.ChainID.Testnet]: common_1.TransactionVersion.Testnet,
    });
    const privateKey = (0, exports.derivePrivateKeyByType)({ rootNode, index, derivationType });
    const address = (0, transactions_1.getAddressFromPrivateKey)(privateKey, txVersion);
    const username = await (0, usernames_1.fetchFirstName)(address, selectedNetwork);
    return { username };
};
exports.fetchUsernameForAccountByDerivationType = fetchUsernameForAccountByDerivationType;
const derivePrivateKeyByType = ({ rootNode, index, derivationType, }) => {
    return derivationType === DerivationType.Wallet
        ? (0, exports.deriveStxPrivateKey)({ rootNode, index })
        : (0, exports.deriveDataPrivateKey)({ rootNode, index });
};
exports.derivePrivateKeyByType = derivePrivateKeyByType;
const deriveStxPrivateKey = ({ rootNode, index }) => {
    const childKey = rootNode.derive(STX_DERIVATION_PATH).deriveChild(index);
    (0, utils_1.assertIsTruthy)(childKey.privateKey);
    return (0, common_1.bytesToHex)((0, encryption_1.compressPrivateKey)(childKey.privateKey));
};
exports.deriveStxPrivateKey = deriveStxPrivateKey;
const deriveDataPrivateKey = ({ rootNode, index }) => {
    const childKey = rootNode.derive(DATA_DERIVATION_PATH).deriveChild(index + common_2.HARDENED_OFFSET);
    (0, utils_1.assertIsTruthy)(childKey.privateKey);
    return (0, common_1.bytesToHex)((0, encryption_1.compressPrivateKey)(childKey.privateKey));
};
exports.deriveDataPrivateKey = deriveDataPrivateKey;
const deriveAccount = ({ rootNode, index, salt, stxDerivationType, }) => {
    const stxPrivateKey = stxDerivationType === DerivationType.Wallet
        ? (0, exports.deriveStxPrivateKey)({ rootNode, index })
        : (0, exports.deriveDataPrivateKey)({ rootNode, index });
    const identitiesKeychain = rootNode.derive(DATA_DERIVATION_PATH);
    const identityKeychain = identitiesKeychain.deriveChild(index + common_2.HARDENED_OFFSET);
    if (!identityKeychain.privateKey)
        throw new Error('Must have private key to derive identities');
    const dataPrivateKey = (0, common_1.bytesToHex)(identityKeychain.privateKey);
    const appsKey = identityKeychain.deriveChild(0 + common_2.HARDENED_OFFSET).privateExtendedKey;
    return {
        stxPrivateKey,
        dataPrivateKey,
        appsKey,
        salt,
        index,
    };
};
exports.deriveAccount = deriveAccount;
//# sourceMappingURL=derive.js.map